<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Object Size Estimation - Calibrated Stereo</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root { --accent: 99 102 241; }
    html, body { height: 100%; font-family: Inter, ui-sans-serif, system-ui; }
    .btn { @apply inline-flex items-center gap-2 px-3 py-2 rounded-xl shadow-sm text-sm font-medium transition active:scale-[.99]; }
    .btn-primary { @apply bg-indigo-600 text-white hover:bg-indigo-700; }
    .btn-ghost { @apply bg-white border border-gray-300 text-gray-700 hover:bg-gray-50; }
    .btn-outline { @apply border border-indigo-600 text-indigo-700 bg-white hover:bg-indigo-50; }
    .chip { @apply inline-flex items-center gap-2 px-2.5 py-1 rounded-full text-xs font-medium bg-gray-100 text-gray-700; }
    .card { @apply bg-white rounded-2xl shadow-lg p-5; }
    .label { @apply block text-xs uppercase tracking-wide text-gray-600 mb-1; }
    .field { @apply w-full border rounded-xl px-3 py-2 focus:outline-none focus:ring-2 focus:ring-indigo-500/50; }
    .seg { @apply grid grid-cols-2 rounded-xl bg-gray-100 p-1; }
    .seg button { @apply rounded-lg py-2 text-sm font-medium; }
    .seg .active { @apply bg-white shadow text-indigo-700; }
    canvas { background: #0b0b0b; border-radius: 18px; }
    .stereo-container { @apply grid grid-cols-2 gap-4; }
    .canvas-wrapper { @apply relative; }
    .loading { @apply opacity-50 pointer-events-none; }
  </style>
</head>
<body class="min-h-screen bg-gradient-to-b from-indigo-50/60 to-white">
  <header class="relative overflow-hidden">
    <div class="pointer-events-none absolute inset-0 bg-[radial-gradient(1200px_600px_at_20%_-10%,rgba(99,102,241,.15),transparent)]"></div>
    <div class="max-w-7xl mx-auto px-6 py-8 flex items-center justify-between">
      <div>
        <h1 class="text-2xl md:text-3xl font-semibold">Object Size Estimation - Calibrated Stereo</h1>
        <p class="text-gray-600">CSc 8830 • Assignment 7 • Task 1</p>
      </div>
      <div class="hidden md:flex items-center gap-2">
        <span class="chip">Stereo Calibration</span>
        <span class="chip">Triangulation</span>
        <span class="chip">3D Measurement</span>
      </div>
    </div>
  </header>

  <main class="max-w-7xl mx-auto px-6 pb-16 grid grid-cols-1 xl:grid-cols-3 gap-6">
    <!-- Left column: controls -->
    <section class="space-y-6 xl:col-span-1">
      <!-- Mode selection -->
      <div class="card space-y-4">
        <div class="flex items-center justify-between">
          <h2 class="font-semibold">1) Mode</h2>
        </div>
        <div class="seg w-full">
          <button id="tabCalib" class="active">Calibration</button>
          <button id="tabMeasure">Measurement</button>
        </div>
        <p class="text-xs text-gray-500">Calibration: Capture stereo pairs with chessboard. Measurement: Click corresponding points in left/right images.</p>
      </div>

      <!-- Calibration panel -->
      <div class="card space-y-4" id="calibPanel">
        <h2 class="font-semibold">2) Stereo Calibration</h2>
        
        <div class="space-y-3">
          <label class="label">Chessboard Pattern</label>
          <div class="grid grid-cols-2 gap-2">
            <input id="chessboardWidth" type="number" class="field" placeholder="Width" value="9" />
            <input id="chessboardHeight" type="number" class="field" placeholder="Height" value="6" />
          </div>
          <input id="squareSize" type="number" step="0.001" class="field" placeholder="Square size (mm)" value="20" />
        </div>

        <div class="space-y-2">
          <label class="label">Capture Stereo Images</label>
          <div class="flex flex-wrap gap-2">
            <input id="leftFileInput" type="file" accept="image/*" class="hidden" />
            <input id="rightFileInput" type="file" accept="image/*" class="hidden" />
            <button id="btnUploadLeft" class="btn btn-outline">Left Image</button>
            <button id="btnUploadRight" class="btn btn-outline">Right Image</button>
          </div>
          <button id="btnDetectChessboard" class="btn btn-primary w-full">Detect & Add to Calibration</button>
          <div class="text-xs text-gray-500">Calibration pairs: <span id="calibPairsCount">0</span></div>
        </div>

        <button id="btnCalibrate" class="btn btn-primary w-full">Perform Stereo Calibration</button>
        
        <div class="space-y-2 text-sm">
          <div class="flex justify-between"><span class="text-gray-600">Baseline:</span> <span id="baselineOut" class="font-mono">—</span></div>
          <div class="flex justify-between"><span class="text-gray-600">Status:</span> <span id="calibStatus">Not calibrated</span></div>
        </div>
        
        <div class="text-xs text-gray-500 p-2 bg-yellow-50 rounded">
          <strong>Note:</strong> Start the backend server: <code>python task1_backend.py</code>
        </div>
      </div>

      <!-- Measurement panel -->
      <div class="card space-y-4 hidden" id="measurePanel">
        <h2 class="font-semibold">3) Object Measurement</h2>
        
        <div class="space-y-3">
          <label class="label">Object Shape</label>
          <select id="objectShape" class="field">
            <option value="rectangular">Rectangular (width × length)</option>
            <option value="circular">Circular (diameter)</option>
            <option value="polygon">Polygon (all edges)</option>
          </select>
        </div>

        <div class="space-y-2">
          <label class="label">Load Stereo Images</label>
          <div class="flex flex-wrap gap-2">
            <input id="measureLeftFile" type="file" accept="image/*" class="hidden" />
            <input id="measureRightFile" type="file" accept="image/*" class="hidden" />
            <button id="btnMeasureLeft" class="btn btn-outline">Left</button>
            <button id="btnMeasureRight" class="btn btn-outline">Right</button>
          </div>
        </div>

        <div class="text-xs text-gray-500 space-y-1">
          <div>Left points: <span id="leftPointsCount">0</span></div>
          <div>Right points: <span id="rightPointsCount">0</span></div>
          <div class="text-orange-600">Click corresponding points in both images</div>
        </div>

        <button id="btnCompute3D" class="btn btn-primary w-full">Compute 3D & Size</button>
        
        <div class="space-y-2 text-sm">
          <div class="card bg-gray-50 border border-gray-100">
            <div class="text-xs text-gray-500">Distance (Z)</div>
            <div id="distanceOut" class="text-lg font-semibold">—</div>
          </div>
          <div class="card bg-gray-50 border border-gray-100">
            <div class="text-xs text-gray-500">Object Size</div>
            <div id="sizeOut" class="text-lg font-semibold">—</div>
          </div>
        </div>

        <div class="space-y-2">
          <label class="label">Units</label>
          <select id="units" class="field">
            <option value="mm" selected>mm</option>
            <option value="cm">cm</option>
            <option value="in">in</option>
          </select>
        </div>

        <button id="btnClearPoints" class="btn btn-ghost w-full">Clear Points</button>
        <button id="btnSaveResult" class="btn btn-outline w-full">Save Annotated Images</button>
      </div>
    </section>

    <!-- Right column: stereo canvases -->
    <section class="xl:col-span-2 space-y-4">
      <div class="card">
        <div class="flex items-center justify-between mb-3">
          <div class="text-sm text-gray-600">
            <span id="instructionText">Load stereo images and click corresponding points</span>
          </div>
        </div>
        <div class="stereo-container">
          <div class="canvas-wrapper">
            <div class="text-xs text-gray-500 mb-2 text-center">Left Camera</div>
            <canvas id="canvasLeft" class="w-full" width="640" height="480"></canvas>
            <div id="leftInfo" class="text-xs text-gray-500 mt-2 text-center">—</div>
          </div>
          <div class="canvas-wrapper">
            <div class="text-xs text-gray-500 mb-2 text-center">Right Camera</div>
            <canvas id="canvasRight" class="w-full" width="640" height="480"></canvas>
            <div id="rightInfo" class="text-xs text-gray-500 mt-2 text-center">—</div>
          </div>
        </div>
      </div>
      <p class="text-xs text-gray-500">Method: Calibrated stereo triangulation. First calibrate cameras using chessboard pattern, then measure objects by clicking corresponding points.</p>
    </section>
  </main>

  <script>
  const API_BASE = 'https://consolidated-assignmentfinal-cv.onrender.com/api';
  
  // State
  const canvasLeft = document.getElementById('canvasLeft');
  const canvasRight = document.getElementById('canvasRight');
  const ctxLeft = canvasLeft.getContext('2d');
  const ctxRight = canvasRight.getContext('2d');

  let mode = 'calib';
  let leftImg = null, rightImg = null;
  let leftScale = { x: 0, y: 0, scale: 1 };
  let rightScale = { x: 0, y: 0, scale: 1 };
  let leftPoints = [], rightPoints = [];
  let calibrationPairs = [];
  let isCalibrated = false;

  const $ = (id) => document.getElementById(id);
  const els = {
    tabCalib: $('tabCalib'), tabMeasure: $('tabMeasure'),
    calibPanel: $('calibPanel'), measurePanel: $('measurePanel'),
    chessboardWidth: $('chessboardWidth'), chessboardHeight: $('chessboardHeight'),
    squareSize: $('squareSize'),
    leftFileInput: $('leftFileInput'), rightFileInput: $('rightFileInput'),
    btnUploadLeft: $('btnUploadLeft'), btnUploadRight: $('btnUploadRight'),
    btnDetectChessboard: $('btnDetectChessboard'),
    calibPairsCount: $('calibPairsCount'),
    btnCalibrate: $('btnCalibrate'),
    baselineOut: $('baselineOut'), calibStatus: $('calibStatus'),
    objectShape: $('objectShape'),
    measureLeftFile: $('measureLeftFile'), measureRightFile: $('measureRightFile'),
    btnMeasureLeft: $('btnMeasureLeft'), btnMeasureRight: $('btnMeasureRight'),
    leftPointsCount: $('leftPointsCount'), rightPointsCount: $('rightPointsCount'),
    btnCompute3D: $('btnCompute3D'),
    distanceOut: $('distanceOut'), sizeOut: $('sizeOut'),
    units: $('units'),
    btnClearPoints: $('btnClearPoints'), btnSaveResult: $('btnSaveResult'),
    instructionText: $('instructionText'),
    leftInfo: $('leftInfo'), rightInfo: $('rightInfo')
  };

  function updateStatus(msg) {
    els.calibStatus.textContent = msg;
  }

  function setMode(m) {
    mode = m;
    els.tabCalib.classList.toggle('active', m === 'calib');
    els.tabMeasure.classList.toggle('active', m === 'measure');
    els.calibPanel.classList.toggle('hidden', m !== 'calib');
    els.measurePanel.classList.toggle('hidden', m !== 'measure');
    leftPoints = [];
    rightPoints = [];
    updatePointCounts();
    draw();
  }

  function updatePointCounts() {
    els.leftPointsCount.textContent = leftPoints.length;
    els.rightPointsCount.textContent = rightPoints.length;
  }

  function fitImageToCanvas(canvas, img) {
    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
    const w = img.width * scale;
    const h = img.height * scale;
    const x = (canvas.width - w) / 2;
    const y = (canvas.height - h) / 2;
    return { x, y, w, h, scale };
  }

  function draw() {
    // Draw left image
    ctxLeft.clearRect(0, 0, canvasLeft.width, canvasLeft.height);
    if (leftImg) {
      leftScale = fitImageToCanvas(canvasLeft, leftImg);
      ctxLeft.drawImage(leftImg, leftScale.x, leftScale.y, leftScale.w, leftScale.h);
      
      // Draw points
      ctxLeft.strokeStyle = '#22c55e';
      ctxLeft.fillStyle = '#22c55e';
      ctxLeft.lineWidth = 2;
      ctxLeft.font = '12px Inter';
      leftPoints.forEach((pt, idx) => {
        const px = leftScale.x + pt[0] * leftScale.scale;
        const py = leftScale.y + pt[1] * leftScale.scale;
        ctxLeft.beginPath();
        ctxLeft.arc(px, py, 5, 0, Math.PI * 2);
        ctxLeft.fill();
        ctxLeft.fillStyle = '#fff';
        ctxLeft.fillText((idx + 1).toString(), px + 8, py - 8);
        ctxLeft.fillStyle = '#22c55e';
      });
    }

    // Draw right image
    ctxRight.clearRect(0, 0, canvasRight.width, canvasRight.height);
    if (rightImg) {
      rightScale = fitImageToCanvas(canvasRight, rightImg);
      ctxRight.drawImage(rightImg, rightScale.x, rightScale.y, rightScale.w, rightScale.h);
      
      // Draw points
      ctxRight.strokeStyle = '#22c55e';
      ctxRight.fillStyle = '#22c55e';
      ctxRight.lineWidth = 2;
      ctxRight.font = '12px Inter';
      rightPoints.forEach((pt, idx) => {
        const px = rightScale.x + pt[0] * rightScale.scale;
        const py = rightScale.y + pt[1] * rightScale.scale;
        ctxRight.beginPath();
        ctxRight.arc(px, py, 5, 0, Math.PI * 2);
        ctxRight.fill();
        ctxRight.fillStyle = '#fff';
        ctxRight.fillText((idx + 1).toString(), px + 8, py - 8);
        ctxRight.fillStyle = '#22c55e';
      });
    }
  }

  function imageCoordsFromCanvas(canvas, scaleInfo, canvasX, canvasY) {
    // Convert canvas click coordinates to image coordinates
    // Account for the offset and scaling
    const imgX = (canvasX - scaleInfo.x) / scaleInfo.scale;
    const imgY = (canvasY - scaleInfo.y) / scaleInfo.scale;
    
    // Round to nearest pixel for accuracy
    return [Math.round(imgX), Math.round(imgY)];
  }

  function imageToBase64(img, maxWidth = 1920, quality = 0.85) {
    const canvas = document.createElement('canvas');
    
    // Resize image if too large to speed up processing
    let width = img.width;
    let height = img.height;
    
    if (width > maxWidth) {
      height = (height * maxWidth) / width;
      width = maxWidth;
    }
    
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, width, height);
    
    // Use JPEG compression instead of PNG for smaller file size
    // JPEG quality 0.85 is a good balance between size and quality
    return canvas.toDataURL('image/jpeg', quality);
  }

  // Event handlers
  els.tabCalib.addEventListener('click', () => setMode('calib'));
  els.tabMeasure.addEventListener('click', () => setMode('measure'));

  // File uploads for calibration
  els.btnUploadLeft.addEventListener('click', () => els.leftFileInput.click());
  els.btnUploadRight.addEventListener('click', () => els.rightFileInput.click());
  
  els.leftFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      leftImg = img;
      draw();
    };
    img.src = url;
  });

  els.rightFileInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      rightImg = img;
      draw();
    };
    img.src = url;
  });

  // File uploads for measurement
  els.btnMeasureLeft.addEventListener('click', () => els.measureLeftFile.click());
  els.btnMeasureRight.addEventListener('click', () => els.measureRightFile.click());
  
  els.measureLeftFile.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      leftImg = img;
      leftPoints = [];
      draw();
      updatePointCounts();
    };
    img.src = url;
  });

  els.measureRightFile.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = () => {
      rightImg = img;
      rightPoints = [];
      draw();
      updatePointCounts();
    };
    img.src = url;
  });

  // Canvas click handlers
  canvasLeft.addEventListener('click', (e) => {
    if (!leftImg) return;
    
    // Get canvas bounding rect and internal size
    const rect = canvasLeft.getBoundingClientRect();
    const canvasWidth = canvasLeft.width;
    const canvasHeight = canvasLeft.height;
    
    // Calculate scale factor between displayed size and internal size
    const scaleX = canvasWidth / rect.width;
    const scaleY = canvasHeight / rect.height;
    
    // Convert click coordinates to canvas internal coordinates
    const cx = (e.clientX - rect.left) * scaleX;
    const cy = (e.clientY - rect.top) * scaleY;
    
    // Recalculate scale info to ensure it's current
    const currentScale = fitImageToCanvas(canvasLeft, leftImg);
    
    // Convert to image coordinates
    const imgPt = imageCoordsFromCanvas(canvasLeft, currentScale, cx, cy);
    
    if (imgPt[0] >= 0 && imgPt[0] < leftImg.width && imgPt[1] >= 0 && imgPt[1] < leftImg.height) {
      if (mode === 'measure') {
        leftPoints.push(imgPt);
        updatePointCounts();
        draw();
      }
    }
  });

  canvasRight.addEventListener('click', (e) => {
    if (!rightImg) return;
    
    // Get canvas bounding rect and internal size
    const rect = canvasRight.getBoundingClientRect();
    const canvasWidth = canvasRight.width;
    const canvasHeight = canvasRight.height;
    
    // Calculate scale factor between displayed size and internal size
    const scaleX = canvasWidth / rect.width;
    const scaleY = canvasHeight / rect.height;
    
    // Convert click coordinates to canvas internal coordinates
    const cx = (e.clientX - rect.left) * scaleX;
    const cy = (e.clientY - rect.top) * scaleY;
    
    // Recalculate scale info to ensure it's current
    const currentScale = fitImageToCanvas(canvasRight, rightImg);
    
    // Convert to image coordinates
    const imgPt = imageCoordsFromCanvas(canvasRight, currentScale, cx, cy);
    
    if (imgPt[0] >= 0 && imgPt[0] < rightImg.width && imgPt[1] >= 0 && imgPt[1] < rightImg.height) {
      if (mode === 'measure') {
        rightPoints.push(imgPt);
        updatePointCounts();
        draw();
      }
    }
  });

  // Detect chessboard and add to calibration
  els.btnDetectChessboard.addEventListener('click', async () => {
    console.log('Detect button clicked');
    console.log('Left image:', leftImg ? 'loaded' : 'missing');
    console.log('Right image:', rightImg ? 'loaded' : 'missing');
    
    if (!leftImg || !rightImg) {
      alert('Please load both left and right images.');
      return;
    }

    // Disable button and show loading
    els.btnDetectChessboard.disabled = true;
    const originalText = els.btnDetectChessboard.textContent;
    els.btnDetectChessboard.textContent = 'Processing...';
    updateStatus('Detecting chessboard...');

    try {
      console.log('Converting images to base64 (resizing if needed)...');
      console.log('Original left image size:', leftImg.width, 'x', leftImg.height);
      console.log('Original right image size:', rightImg.width, 'x', rightImg.height);
      const leftData = imageToBase64(leftImg);
      const rightData = imageToBase64(rightImg);
      console.log('Left data length:', (leftData.length / 1024 / 1024).toFixed(2), 'MB');
      console.log('Right data length:', (rightData.length / 1024 / 1024).toFixed(2), 'MB');
      
      const patternSize = [
        parseInt(els.chessboardWidth.value) || 9,
        parseInt(els.chessboardHeight.value) || 6
      ];
      const squareSize = parseFloat(els.squareSize.value) || 20;
      console.log('Pattern size:', patternSize);
      console.log('Square size:', squareSize);

      console.log('Sending request to:', `${API_BASE}/detect_chessboard`);
      
      // Create AbortController for timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
      
      const response = await fetch(`${API_BASE}/detect_chessboard`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          left_image: leftData,
          right_image: rightData,
          pattern_size: patternSize,
          square_size: squareSize
        }),
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);

      console.log('Response status:', response.status);
      if (!response.ok) {
        const errorText = await response.text();
        console.error('Response error:', errorText);
        throw new Error(`Server error: ${response.status} - ${errorText}`);
      }

      const result = await response.json();
      console.log('Response result:', result);
      
      if (result.success) {
        calibrationPairs.push({
          left_image: leftData,
          right_image: rightData,
          left_corners: result.left_corners,
          right_corners: result.right_corners
        });
        els.calibPairsCount.textContent = calibrationPairs.length;
        updateStatus(`Found chessboard! Pairs: ${calibrationPairs.length}`);
        
        // Draw detected corners
        draw();
        alert(`Chessboard detected successfully! Total pairs: ${calibrationPairs.length}`);
      } else {
        // Try debug endpoint to get more info
        try {
          const debugResponse = await fetch(`${API_BASE}/debug_chessboard`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              left_image: leftData,
              right_image: rightData,
              pattern_size: patternSize
            })
          });
          const debugResult = await debugResponse.json();
          console.log('Debug info:', debugResult);
          
          let errorMsg = 'Could not detect chessboard: ' + result.error + '\n\n';
          errorMsg += `Debug Info:\n`;
          errorMsg += `- Left image: ${debugResult.left_image_shape[1]}x${debugResult.left_image_shape[0]} pixels\n`;
          errorMsg += `- Right image: ${debugResult.right_image_shape[1]}x${debugResult.right_image_shape[0]} pixels\n`;
          errorMsg += `- Left brightness: ${debugResult.left_mean_brightness.toFixed(1)} (0-255)\n`;
          errorMsg += `- Right brightness: ${debugResult.right_mean_brightness.toFixed(1)} (0-255)\n`;
          errorMsg += `- Left contrast: ${debugResult.left_contrast.toFixed(1)}\n`;
          errorMsg += `- Right contrast: ${debugResult.right_contrast.toFixed(1)}\n`;
          errorMsg += `\nTips:\n`;
          errorMsg += `- Ensure chessboard fills at least 30% of the image\n`;
          errorMsg += `- Check that pattern size matches (count inner corners, not squares)\n`;
          errorMsg += `- Ensure good lighting and contrast\n`;
          errorMsg += `- Make sure chessboard is flat and not at extreme angles`;
          
          alert(errorMsg);
        } catch (debugErr) {
          alert('Could not detect chessboard: ' + result.error);
        }
        updateStatus('Detection failed');
      }
    } catch (e) {
      console.error('Full error:', e);
      if (e.name === 'AbortError') {
        alert('Request timed out after 30 seconds.\n\nYour images may be too large. Try using smaller images or check your internet connection.');
        updateStatus('Request timed out');
      } else {
        alert('Error: ' + e.message + '\n\nCheck browser console (F12) for details.\nMake sure the backend server is running on port 5001.');
        updateStatus('Error: ' + e.message);
      }
    } finally {
      // Re-enable button
      els.btnDetectChessboard.disabled = false;
      els.btnDetectChessboard.textContent = originalText;
    }
  });

  // Perform stereo calibration
  els.btnCalibrate.addEventListener('click', async () => {
    if (calibrationPairs.length < 3) {
      alert('Need at least 3 calibration pairs. Current: ' + calibrationPairs.length);
      return;
    }

    try {
      const patternSize = [
        parseInt(els.chessboardWidth.value) || 9,
        parseInt(els.chessboardHeight.value) || 6
      ];
      const squareSize = parseFloat(els.squareSize.value) || 20;

      const imagePairs = calibrationPairs.map(pair => ({
        left: pair.left_image,
        right: pair.right_image
      }));

      const response = await fetch(`${API_BASE}/calibrate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: 'default',
          pattern_size: patternSize,
          square_size: squareSize,
          image_pairs: imagePairs
        })
      });

      const result = await response.json();
      if (result.success) {
        isCalibrated = true;
        els.baselineOut.textContent = result.baseline.toFixed(2) + ' mm';
        updateStatus('Calibration successful!');
        alert(`Stereo calibration completed!\nBaseline: ${result.baseline.toFixed(2)} mm\nReprojection error: ${result.reprojection_error.toFixed(4)}`);
      } else {
        alert('Calibration failed: ' + result.error);
      }
    } catch (e) {
      alert('Error: ' + e.message + '\nMake sure the backend server is running.');
      console.error(e);
    }
  });

  // Compute 3D coordinates
  els.btnCompute3D.addEventListener('click', async () => {
    if (!isCalibrated) {
      alert('Please calibrate the stereo system first.');
      return;
    }
    if (leftPoints.length === 0 || rightPoints.length === 0) {
      alert('Please click points in both images.');
      return;
    }
    if (leftPoints.length !== rightPoints.length) {
      alert('Number of points must match in both images.');
      return;
    }

    try {
      // Triangulate points
      const triangResponse = await fetch(`${API_BASE}/triangulate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          id: 'default',
          left_points: leftPoints,
          right_points: rightPoints
        })
      });

      const triangResult = await triangResponse.json();
      if (!triangResult.success) {
        alert('Triangulation failed: ' + triangResult.error);
        return;
      }

      const points3D = triangResult.points_3d;
      const avgZ = triangResult.avg_distance;

      // Measure size
      const measureResponse = await fetch(`${API_BASE}/measure_size`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          points_3d: points3D,
          shape: els.objectShape.value,
          units: els.units.value
        })
      });

      const measureResult = await measureResponse.json();
      if (measureResult.success) {
        els.distanceOut.textContent = measureResult.avg_distance_z.toFixed(2) + ' ' + els.units.value;
        els.sizeOut.textContent = measureResult.size;
      } else {
        alert('Measurement failed: ' + measureResult.error);
      }
    } catch (e) {
      alert('Error: ' + e.message + '\nMake sure the backend server is running.');
      console.error(e);
    }
  });

  els.btnClearPoints.addEventListener('click', () => {
    leftPoints = [];
    rightPoints = [];
    updatePointCounts();
    draw();
  });

  els.btnSaveResult.addEventListener('click', () => {
    if (!leftImg || !rightImg) {
      alert('No images to save.');
      return;
    }
    draw();
    const leftData = canvasLeft.toDataURL('image/png');
    const rightData = canvasRight.toDataURL('image/png');
    const a1 = document.createElement('a');
    a1.download = 'stereo_left_annotated.png';
    a1.href = leftData;
    a1.click();
    const a2 = document.createElement('a');
    a2.download = 'stereo_right_annotated.png';
    a2.href = rightData;
    a2.click();
  });

  // Initialize
  setMode('calib');
  
  // Verify all elements are found
  console.log('Initializing...');
  console.log('Detect button element:', els.btnDetectChessboard);
  if (!els.btnDetectChessboard) {
    console.error('ERROR: btnDetectChessboard element not found!');
    alert('Error: Button element not found. Check HTML structure.');
  }
  
  // Check backend health
  fetch(`${API_BASE}/health`)
    .then(r => r.json())
    .then(data => {
      if (data.status === 'ok') {
        updateStatus('Backend connected');
        console.log('Backend is connected');
      }
    })
    .catch((e) => {
      updateStatus('Backend not connected - start server');
      console.error('Backend connection failed:', e);
    });
  </script>
</body>
</html>
